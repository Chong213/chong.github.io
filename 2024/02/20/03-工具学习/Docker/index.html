<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="Docker https:&#x2F;&#x2F;docker.easydoc.net&#x2F;doc&#x2F;81170005&#x2F;cCewZWoN&#x2F;lTKfePfP 相似：Buildah、kaniko、buildkit  简介与安装What？Docker是一个应用打包、分发、部署的工具。 也可以理解为一个轻量的虚拟机，它只虚拟软件需要的运行环境，多余的一点也不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管需要与否的软件。 虚">
<meta property="og:type" content="article">
<meta property="og:title">
<meta property="og:url" content="http://example.com/2024/02/20/03-%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/Docker/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Docker https:&#x2F;&#x2F;docker.easydoc.net&#x2F;doc&#x2F;81170005&#x2F;cCewZWoN&#x2F;lTKfePfP 相似：Buildah、kaniko、buildkit  简介与安装What？Docker是一个应用打包、分发、部署的工具。 也可以理解为一个轻量的虚拟机，它只虚拟软件需要的运行环境，多余的一点也不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管需要与否的软件。 虚">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/404.jpg">
<meta property="article:published_time" content="2024-02-20T08:24:05.729Z">
<meta property="article:modified_time" content="2023-08-11T02:42:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/404.jpg">




<!-- Favicon -->

    <link href='/img/favicon.svg?v=2.1.10' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/img/favicon.svg?v=2.1.10' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"example.com","author":null,"root":"/","typed_text":null,"theme_version":"2.1.10","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/img/favicon.svg","icon16":"/img/favicon.svg","icon32":"/img/favicon.svg","appleTouchIcon":null,"webmanifest":null,"visibilitychange":false,"hidden":"/failure.ico","showText":"(/≧▽≦/)Hey! Good again!","hideText":"(●—●)Oh, crash!"},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms","author":"Post author: ","copyright_link":"Post link: ","copyright_license_title":"Copyright Notice: ","copyright_license_content":"All articles in this blog are licensed under undefined unless otherwise stated.","copy_success":"Copied","copy_failure":"Copy failed","open_read_mode":"Enter reading mode","exit_read_mode":"Exit reading mode","notice_outdate_message":"It has been undefined days since the last update, the content of the article may be outdated.","sticky":"TOP","just":"Just","min":"minutes ago","hour":"hours ago","day":"days ago","month":"months ago"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","user_tag":"fas fa-user-alt","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"default","height_limit":false},"toc":{"post_title":true},"live_time":{"start_time":"","prefix":"The blog has been lovely to run undefined day"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2023-08-11 10:42:26"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.1.10" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->
 
<meta name="generator" content="Hexo 7.1.1"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/img/favicon.svg">
    
    
        <div class="trm-logo-text">
            Cao<span>Chong</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    Home
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a  href="/archives/" target="">
                    Archives
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/img/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2024
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div class="trm-page-sidebar col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/img/avatar.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        星唯向导
    </h5>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com/chong-zzxy" title="Github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
        <a href="https://gitee.com" title="gitee" rel="nofollow" target="_blank">
            <i class="iconfont iconfont cg-gitee"></i>
        </a>
    
        <a href="https://space.bilibili.com/271039719" title="BiliBili" rel="nofollow" target="_blank">
            <i class="iconfont iconfont icon-bilibili"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                name:
            </div>
            <div class="trm-label trm-label-light">
                Caochong
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                from:
            </div>
            <div class="trm-label trm-label-light">
                China
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                born:
            </div>
            <div class="trm-label trm-label-light">
                1999.01.10
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                love:
            </div>
            <div class="trm-label trm-label-light">
                AI | life | 粘粘
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div class="trm-page-content col-lg-8">
                <div id="trm-content" class="trm-content">
                    <div class="trm-post-info row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            02/20
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            16:24
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP</a></p>
<p>相似：Buildah、kaniko、buildkit</p>
</blockquote>
<h2 id="简介与安装"><a href="#简介与安装" class="headerlink" title="简介与安装"></a>简介与安装</h2><h3 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h3><p>Docker是一个应用打包、分发、部署的工具。</p>
<p>也可以理解为一个轻量的虚拟机，它只虚拟软件需要的运行环境，多余的一点也不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管需要与否的软件。</p>
<h3 id="虚拟机对比"><a href="#虚拟机对比" class="headerlink" title="虚拟机对比"></a>虚拟机对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>普通虚拟机</th>
<th>Docker</th>
</tr>
</thead>
<tbody><tr>
<td>跨平台</td>
<td>通常在能在桌面级系统运行，例如Windows&#x2F;Mac</td>
<td>支持系统非常多，各类的Windows和Linux</td>
</tr>
<tr>
<td>性能</td>
<td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来</td>
<td>性能好，只虚拟软件所需运行环境，最大化减少没用配置</td>
</tr>
<tr>
<td>自动化</td>
<td>需要手动安装所有东西</td>
<td>一个命令就可以自动部署好所需环境</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定性不高，不同系统差异大</td>
<td>稳定性好，不同系统都一样部署方式</td>
</tr>
</tbody></table>
<h3 id="打包-分发-部署"><a href="#打包-分发-部署" class="headerlink" title="打包+分发+部署"></a>打包+分发+部署</h3><p>打包：将软件所需的依赖、第三方库、软件打包到一起，变成一个安装包</p>
<p>分发：把打包好的“安装包”上传到一个镜像仓库，便于其他人获取和安装</p>
<p>部署：获取“安装包”后，一个命令就可以运行应用，自动模拟出一摸一样的环境</p>
<h3 id="部署优势"><a href="#部署优势" class="headerlink" title="部署优势"></a>部署优势</h3><p>常规应用开发部署方式：在Windows上开发、测试<code>--&gt;</code>到Linux服务器配置运行环境部署。（问题：当前机器上跑没问题，服务器出各种问题）</p>
<p>用Docker开发部署流程：Windows上开发、测试<code>--&gt;</code>打包为Docker镜像（可以理解为软件安装包）<code>--&gt;</code>各种服务器上只需要一个命令部署（优点：保证一致的运行环境）（如：易文档，SVNBucket的私有化部署就是用Docker）</p>
<h3 id="用来做什么"><a href="#用来做什么" class="headerlink" title="用来做什么"></a>用来做什么</h3><ul>
<li>应用分发、部署、方便传播给他人安装，特别是开源软件和提供私有部署的应用。</li>
<li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），如：Redis&#x2F;MongoDB&#x2F;ElasticSearch&#x2F;ELK</li>
<li>多个版本软件共存，不污染系统</li>
<li>Windows上体验&#x2F;学习各种Linux系统</li>
</ul>
<h3 id="镜像-容器-重"><a href="#镜像-容器-重" class="headerlink" title="镜像+容器(重)"></a>镜像+容器(重)</h3><p>镜像（Image）：是一个包含有文件系统的面向Docker引擎的只读模板。镜像是一个模板,装了一些系统的配置文件, 我们可以通过镜像建立更多的容器, 容器从镜像启动时,Docker在镜像的上层创建一个可写层, 镜像本身不变。</p>
<p>容器（Container）：容器是基于镜像创建, 相互隔离的, 可以理解为小型虚拟机，真正的执行单元。</p>
<p>仓库（Repository）：存放镜像的仓库</p>
<p>注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分. <a href="https://link.juejin.cn/?target=https://hub.docker.com/"><code>Docker Hub</code></a>是Docker公司提供的一个注册服务器（Register）来保存多个仓库</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>桌面版：<a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></p>
<p>服务器版：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p>
<ol>
<li>指令安装：<code>yum install docker-ce</code></li>
<li>启动：<code>systemctl start docker</code></li>
<li>停止：<code>systemctl stop docker</code></li>
<li>重启：<code>systemctl restart docker</code></li>
<li>查看状态：<code>systemctl status docker</code></li>
<li>开机启动：<code>systemctl enable docker</code></li>
<li>查看概要信息：<code>docker info</code></li>
<li>查看帮助文档：<code>docker --help</code></li>
</ol>
<h2 id="快速安装软件"><a href="#快速安装软件" class="headerlink" title="快速安装软件"></a>快速安装软件</h2><h3 id="直接安装的缺点："><a href="#直接安装的缺点：" class="headerlink" title="直接安装的缺点："></a>直接安装的缺点：</h3><ul>
<li>安装麻烦，可能有各种依赖，运行报错。</li>
<li>可能对windows并不友好，运行存在兼容性问题。</li>
<li>不方便安装多版本软件，不能共存。</li>
<li>电脑安装一堆软件，拖慢电脑速度。</li>
<li>不同电脑和硬件，安装方式不一样。</li>
</ul>
<h3 id="Docker安装的优点："><a href="#Docker安装的优点：" class="headerlink" title="Docker安装的优点："></a>Docker安装的优点：</h3><ul>
<li>一个命令就可以安装好，快速方便</li>
<li>有大量的镜像，可直接使用</li>
<li>没有系统兼容问题，Linux 专享软件也照样跑</li>
<li>支持软件多版本共存</li>
<li>用完就丢，不拖慢电脑速度</li>
<li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li>
</ul>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个Dockerfile作用是打一个python3项目环境 </span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span>-alpine </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app </span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt -i https://pypi.douban.com/simple </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;main.py&quot;</span>] </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#这个Dockerfile作用Dockerfile部署django项目 </span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span> </span><br><span class="line"><span class="keyword">MAINTAINER</span> annlin </span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> requeriments.txt /home </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update &amp;&amp; yum -y install mysql &amp;&amp; yum -y install python3-pip &amp;&amp; pip3 install -r requirements.txt </span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> autoTest /home/ WORKDIR /home/autoTest </span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span> </span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> uwsgi --ini uwsgi.ini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#肉鸡检测</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span>		<span class="comment"># 底</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> author=<span class="string">&quot;CG&quot;</span>	<span class="comment"># 作者信息</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app 			<span class="comment"># 当前目录下的代码复制到 容器中/app目录</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> . /app 		<span class="comment"># 设置容器运行目录</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install python3-pip &amp;&amp; pip install -r requirements.txt &amp;&amp; npm install --registry=https://registry.npm.taobao.org &amp;&amp; npm run serve</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span> <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>实用技巧</code>：<br>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。<br>例如上面的底是<code>node:11</code>，我们可以运行<code>docker run -it -d node:11 bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。<br>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p>
</blockquote>
<h4 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h4><ol>
<li>指令大小写不敏感，为了区分习惯上用大写</li>
<li>Dockerfile 非注释行第一行必须是 FROM</li>
<li>文件名必须是 Dockerfile</li>
<li>Dockerfile 指定一个专门的目录为工作空间</li>
<li>所有引入映射的文件必须在这个工作空间目录下</li>
<li>Dockerfile 工作空间目录下支持隐藏文件(.dockeringore)</li>
<li>(.dockeringore)作用是用于存放不需要打包导入镜像的文件，根目录就是工作空间目录</li>
<li>每一条指令都会生成一个镜像层，镜像层多了执行效率就慢，能写成一条指定的就写成一条</li>
</ol>
<h4 id="常用指令详解"><a href="#常用指令详解" class="headerlink" title="常用指令详解"></a>常用指令详解</h4><blockquote>
<p>一般语句为：<br>FROM WORKDIR COPY-ADD RUN CMD-ENTRYPOINT<br>ENTRYPOINT非json则以ENTRYPOT为准，如果ENTRYPOINT和CMD都是JSON则ENTRYPOINT+CMD拼接成shell</p>
</blockquote>
<h5 id="1-FROM：基础镜像"><a href="#1-FROM：基础镜像" class="headerlink" title="1. FROM：基础镜像"></a>1. <code>FROM</code>：基础镜像</h5><ul>
<li><p>FROM是Dockerfile文件开篇第一个非注释行代码</p>
</li>
<li><p>用于为镜像文件构建过程指定基础镜像，后续的指令都基于该基础镜像环境运行</p>
</li>
<li><p>基础镜像可以是任何一个镜像文件</p>
</li>
<li><p>docker build 会在docker宿主机上查找指定的文件，如未找到会自动去Docker Hub Registry上拉取</p>
</li>
</ul>
<h6 id="FROM指令-语法解析"><a href="#FROM指令-语法解析" class="headerlink" title="FROM指令 语法解析"></a>FROM指令 语法解析</h6><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p>语义：<code>FROM</code>指令开始一个新的构建阶段，设置后续构建依赖的基础镜像，<code>Dockerfile</code>必须以<code>FROM</code>开始。镜像可以是任意有效镜像</p>
<h5 id="2-LABLE：镜像描述信息"><a href="#2-LABLE：镜像描述信息" class="headerlink" title="2. LABLE：镜像描述信息"></a>2. <code>LABLE</code>：镜像描述信息</h5><ul>
<li>LABLE author&#x3D;”annlin”</li>
<li>MAINTAINER：镜像作者信息（已废弃，由此代替）</li>
</ul>
<h5 id="3-COPY：从-Docker-宿主机复制文件至创建的新镜像文件"><a href="#3-COPY：从-Docker-宿主机复制文件至创建的新镜像文件" class="headerlink" title="3. COPY：从 Docker 宿主机复制文件至创建的新镜像文件"></a>3. <code>COPY</code>：从 Docker 宿主机复制文件至创建的新镜像文件</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> &lt;src&gt; &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,.... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><src>：要复制的源文件或目录，支持使用通配符</p>
<ul>
<li><src>必须是build上下文中的路径，不能是其父目录路径</li>
<li>如果<src>是目录，则其内部文件和子目录都会被递归复制，但是<src>目录本身不会被复制</li>
<li>如果指定了多个<src>,或者<src>中使用了通配符，则<dest>必须是一个目录，且必须以&#x2F;结尾</li>
</ul>
</li>
<li><p><dest>：目标路径，即正在创建的images的文件系统路径</p>
<ul>
<li>建议使用绝对路径，否则COPY指定以WORKDIR为其实路径</li>
<li>如果<dest>不存在，将会被自动创建，包括其父目录路径一起创建\</li>
</ul>
</li>
<li><p>复制文件 <code>COPY testFile /mnt</code></p>
</li>
<li><p>复制目录 <code>COPY testDir /mnt/testDir</code></p>
<ul>
<li><p>testDir下所有文件和目录都会被递归复制</p>
</li>
<li><p><strong>目标路径要写testDir，否则会复制到&#x2F;mnt下</strong></p>
</li>
</ul>
</li>
</ol>
<h5 id="4-ADD：类似于-COPY-指令，ADD-支持-tar-文件和-URL-路径"><a href="#4-ADD：类似于-COPY-指令，ADD-支持-tar-文件和-URL-路径" class="headerlink" title="4. ADD：类似于 COPY 指令，ADD 支持 tar 文件和 URL 路径"></a>4. <code>ADD</code>：类似于 COPY 指令，ADD 支持 tar 文件和 URL 路径</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> &lt;src&gt; &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,...<span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果<src>为URL且<dest>不以<code>/</code>结尾，则<src>指定的文件将被下载并直接被创建为<fimename>，</p>
<p>如果<dest>以<code>/</code>结尾，则文件名URL指定的文件将被下载并保存为<dest>&#x2F;fimename</p>
</li>
<li><p>如果<src>是一个压缩文件(tar),会被解压为一个目录，但是通过URL下载的tar文件不会被解压</p>
</li>
<li><p>如果是多个<src>，或者是同一个<src>使用了通配符，则<dest>必须是以<code>/</code>结尾的目录，</p>
<p>如果<dest>不以<code>/</code>结尾，则<src>会被作为一个普通文件,<src>内容讲被写入到<dest></p>
</li>
</ol>
<h5 id="5-WORKDIR：用于为-Dockerfile-设定工作目录"><a href="#5-WORKDIR：用于为-Dockerfile-设定工作目录" class="headerlink" title="5. WORKDIR：用于为 Dockerfile 设定工作目录"></a>5. <code>WORKDIR</code>：用于为 Dockerfile 设定工作目录</h5><blockquote>
<p>指定shell语句运行在那个路径下</p>
</blockquote>
<ol>
<li><p>WORKDIR &#x2F;mnt，如果目录不存在会自动创建，包括他的父目录</p>
</li>
<li><p>一个Dockerfile中WORKDIR可以出现多次，其路径也可以为相对路径,相对路径是基于前一个WORKDIR路径</p>
</li>
<li><p>WORKDIR也可以调用ENV指定的变量</p>
</li>
<li><p>例 :</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> python:latest</span><br><span class="line"><span class="keyword">workdir</span><span class="language-bash"> /mnt</span></span><br><span class="line"><span class="keyword">run</span><span class="language-bash"> <span class="built_in">touch</span> a.txt</span></span><br><span class="line"><span class="keyword">workdir</span><span class="language-bash"> /usr</span></span><br><span class="line"><span class="keyword">run</span><span class="language-bash"> <span class="built_in">touch</span> b.txt</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="6-VOLUME：数据卷，指定映射文件"><a href="#6-VOLUME：数据卷，指定映射文件" class="headerlink" title="6. VOLUME：数据卷，指定映射文件"></a>6. <code>VOLUME</code>：数据卷，指定映射文件</h5><blockquote>
<p>用于在 image 中创建挂载点目录，以挂载 Docker host 上的卷或者其他容器上的卷</p>
</blockquote>
<ol>
<li>VOLUM mount_point</li>
<li>VOLUM [“mount_point1”,”mount_point2”]</li>
<li>如果挂载点目录下有文件存在，docker run命令会在卷挂在完成后将所有文件复制都容器中</li>
</ol>
<h5 id="7-EXPOSE：为容器打开指定的监听端口以-实现与外部通信"><a href="#7-EXPOSE：为容器打开指定的监听端口以-实现与外部通信" class="headerlink" title="7. EXPOSE：为容器打开指定的监听端口以 实现与外部通信"></a>7. <code>EXPOSE</code>：为容器打开指定的监听端口以 实现与外部通信</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; &lt;/portocol&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><port>：端口号</p>
</li>
<li><p></portocol>：协议类型，默认为TCP协议</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span>/tcp <span class="number">8081</span>/udp</span><br></pre></td></tr></table></figure></li>
</ol>
<p>不会直接对外暴露这里的端口，只有在run的啥时候加上-p（大写）才会将EXPOSE的端口暴露出去</p>
<h5 id="8-ENV：为镜像定义所需的环境变量"><a href="#8-ENV：为镜像定义所需的环境变量" class="headerlink" title="8. ENV：为镜像定义所需的环境变量"></a>8. <code>ENV</code>：为镜像定义所需的环境变量</h5><ol>
<li><p>ENV key value（key之后的所有内容都会被视为value,因此，一次只能设置一个变量）</p>
</li>
<li><p>ENV key&#x3D;value</p>
<ul>
<li>可以设置多个变量，每个key&#x3D;value键值对为一个变量</li>
<li>如果values中包含<strong>空格</strong>需要用反斜杠转义，也可以对values加引号进行标识，反斜杠也可以用于续行</li>
</ul>
</li>
<li><p>调用格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$variable_name 或者 $&#123;variable_name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义多个变量建议使用第二种方式，以便在同一层中完成</p>
</li>
<li><p>例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DOC_DIR=/mnt/doc <span class="keyword">COPY</span><span class="language-bash"> index.html <span class="variable">$&#123;DOC_DIR:-/mnt/doc&#125;</span></span></span><br><span class="line"><span class="comment">#-：如果DOC_DIR不存在则使用-后面的默认值</span></span><br><span class="line"><span class="comment">#+：如果DOC_DIR存在则使用+后面的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="9-RUN：docker-build-镜像构建的时候需要执行的-shell-命令默认”-bin-sh-c”运行"><a href="#9-RUN：docker-build-镜像构建的时候需要执行的-shell-命令默认”-bin-sh-c”运行" class="headerlink" title="9. RUN：docker build 镜像构建的时候需要执行的 shell 命令默认”&#x2F;bin&#x2F;sh -c”运行"></a>9. <code>RUN</code>：docker build 镜像构建的时候需要执行的 shell 命令默认”&#x2F;bin&#x2F;sh -c”运行</h5><ol>
<li>docker build过程中需要执行的命令</li>
<li>RUN是在镜像构建完成之后运行结束</li>
<li>RUN执行的命令只能<strong>基于基础镜像</strong>的命令，执行之前先要确定基础镜像是否有该命令</li>
<li>一个Dockerfile可以写多个RUN<ul>
<li>语法一：RUN command1 &amp;&amp; command2<ol>
<li>通常是shell命令且以”&#x2F;bin&#x2F;sh -c”来运行它，此时运行为shell的子进程</li>
<li>进程是在容器中的PID!&#x3D;1，不能接受unix信号，当使用docker stop将无法接收到</li>
<li><code>RUN echo &quot;test_demo&quot; &gt; a.txt</code> 此时可以使用shell特性</li>
</ol>
</li>
<li>语法二：RUN [“executable”, “param1”, “param2”]<ol>
<li>executable为要运行的命令</li>
<li>param1为命令运行的参数</li>
<li>不会以”&#x2F;bin&#x2F;sh -c”运行（非shell子进程），因此不支持shell操作符如变量替换和通配符（?, *等）</li>
<li>如果运行命令需要依赖shell特性可以增加参数，手动启动为shell的子进程RUN[“&#x2F;bin&#x2F;bash”, “-c”, “executable”, “param1”]</li>
<li>list中的参数要使用双引号</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="10-CMD：启动容器指定默认要运行的程序或命令，默认”-bin-sh-c”运行"><a href="#10-CMD：启动容器指定默认要运行的程序或命令，默认”-bin-sh-c”运行" class="headerlink" title="10. CMD：启动容器指定默认要运行的程序或命令，默认”&#x2F;bin&#x2F;sh -c”运行"></a>10. <code>CMD</code>：启动容器指定默认要运行的程序或命令，默认”&#x2F;bin&#x2F;sh -c”运行</h5><blockquote>
<p>CMD （指定镜像启动运行的脚本，只有容器真正运行的时候才会运行的脚本，执行后容器的生命周期即结束，且一般为阻塞式语句，如tail语句）</p>
</blockquote>
<ol>
<li><p>docker run过程中需要执行的命令</p>
</li>
<li><p>CMD运行结束后容器就将终止</p>
</li>
<li><p>CMD指定的命令将可以被docker run最后面的命令覆盖</p>
</li>
<li><p>一个Dockerfile写多个CMD只有最后一个CMD会生效</p>
<ul>
<li><p>语法一：CMD command</p>
<ol>
<li>通常是shell命令且以”&#x2F;bin&#x2F;sh -c”来运行它，此时运行为shell的子进程</li>
<li>进程是在容器中的PID!&#x3D;1，不能接受unix信号，当使用docker stop将无法接收到</li>
<li><code>CMD /bin/https -f -h $&#123;http&#125;</code> 此时在运行容器的时候加-it参数无法进入交互式模式，需要docker exec进入交互模式</li>
</ol>
</li>
<li><p>语法二：CMD [“executable”, “param1”, “param2”]</p>
<ol>
<li>不会以”&#x2F;bin&#x2F;sh -c”运行(非shell子进程)，因此不支持shell操作符如变量替换和通配符(?,*等)</li>
<li>如果运行命令需要依赖shell特性可以增加参数，手动启动为shell的子进程 CMD <a href="%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8">“&#x2F;bin&#x2F;bash”,”-c”,”executable”,”param1”,”param2”</a></li>
</ol>
</li>
<li><p>CMD [“param1”,”param2”]</p>
<p>需要结合<code>ENTRYPOINT</code>指令提供默认参数使用</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec形式，这是首选形式.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 提供给ENTRYPOINT的默认参数.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell形式.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>



<h5 id="11-ENTRYPOINT：类型-CMD-指令的功能，用于为容器指定默认运行程序或命令"><a href="#11-ENTRYPOINT：类型-CMD-指令的功能，用于为容器指定默认运行程序或命令" class="headerlink" title="11. ENTRYPOINT：类型 CMD 指令的功能，用于为容器指定默认运行程序或命令"></a>11. <code>ENTRYPOINT</code>：类型 CMD 指令的功能，用于为容器指定默认运行程序或命令</h5><ol>
<li><p>与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数覆盖，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序</p>
</li>
<li><p>docker run命令的 –entrypoint选项参数可以覆盖ENTRYPOINT指令指定的程序</p>
</li>
<li><p>一个Dockerfile中可以有多个ENTRYPOINT，但是只有最后一个会生效</p>
</li>
<li><p>ENTRYPOINT主要用于shell作为启动其他进程的父进程，后面跟的参数被当成子进程来启动</p>
<ul>
<li>语法一：ENTRYPOINT command</li>
<li>语法二：ENTRYPOINT [“&#x2F;bin&#x2F;bash”,”param1”,”param2”]</li>
</ul>
</li>
</ol>
<h5 id="12-CMD-和-ENTRYPOINT-同时存在-Dockerfile-中"><a href="#12-CMD-和-ENTRYPOINT-同时存在-Dockerfile-中" class="headerlink" title="12.  CMD 和 ENTRYPOINT 同时存在 Dockerfile 中"></a>12.  CMD 和 ENTRYPOINT 同时存在 Dockerfile 中</h5><ol>
<li><p>CMD的值会当做参数传递给ENTRYPOINT</p>
</li>
<li><p>实现使用shell子进程启动httpd</p>
</li>
<li><p>如果docker run再传入参数，是传给ENTRYPOINT的，因为ENTRYPOINT有自己的参数，此时CMD参数会被ducker run后面跟的参数覆盖，并不是覆盖ENTRYPOINT的参数，要覆盖ENTRYPOINT的参数需要使用–entrypoint选项 CMD [“&#x2F;bin&#x2F;httpd&#x2F;“,”-f”] ENTRYPOINT &#x2F;bin&#x2F;bash -c -h 通过传参启动容器 FROM python:latest LABLE auth&#x3D;”haili” ENV NGX_DOC_ROOT&#x3D;’&#x2F;data&#x2F;web&#x2F;html’ ADD entrypoint.sh &#x2F;bin&#x2F; CMD [‘&#x2F;usr&#x2F;sbin&#x2F;nginx’,’-g’,’daemon off;’] ENTRYPOINT [‘&#x2F;bin&#x2F;sh’,’-c’,’&#x2F;bin&#x2F;entrypoint.sh’]</p>
<p>先执行ENTRYPOINT，然后讲CMD的值当做参数传给ENTRYPOINT进行执行</p>
</li>
</ol>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a><code>注</code></h5><h6 id="CMD-与-RUN"><a href="#CMD-与-RUN" class="headerlink" title="CMD 与 RUN"></a>CMD 与 RUN</h6><p>CMD与RUN都是用来在dockerfile中配置命令的，它们之间有所<code>不同</code>：</p>
<ol>
<li><p>应用阶段</p>
<ul>
<li>RUN是镜像构建步骤，RUN命令后将容器的状态提交到容器镜像。</li>
<li>CMD是启动构建镜像时，默认情况下，容器执行的命令。</li>
</ul>
</li>
<li><p>执行次数</p>
<ul>
<li>一个dockerfile可以具有很多RUN步骤，这些步骤相互叠加最后生成镜像。</li>
<li>dockerfile将使用最后一个CMD指令，使用CMD启动容器时可以覆盖docker run $image $other_command。</li>
</ul>
</li>
<li><p>总结</p>
<p>RUN和CMD指令在基于dockerfile构建镜像时，起到了非常大的作用。</p>
</li>
</ol>
<h3 id="Build为镜像（安装包）和运行"><a href="#Build为镜像（安装包）和运行" class="headerlink" title="Build为镜像（安装包）和运行"></a>Build为镜像（安装包）和运行</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>docker build -t test:v1 .</code></p>
<blockquote>
<p><code>-t</code> 设置镜像名字和版本号，名字test，版本号为v1</p>
<p>命令参考：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<p><code>.</code>指在当前目录</p>
</blockquote>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>docker run -p 8080:8080 --name test-hello test:v1</code></p>
<blockquote>
<p><code>-p</code> 映射容器内端口到宿主机<br><code>--name</code> 容器名字<br><code>-d</code> 后台运行<br>命令参考文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p>
</blockquote>
<h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前运行中的容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="comment"># 查看镜像列表</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除指定 id 的容器</span></span><br><span class="line">docker rm container-id</span><br><span class="line"><span class="comment"># 停止/启动指定 id 的容器</span></span><br><span class="line">docker stop/start container-id</span><br><span class="line"><span class="comment"># 删除指定 id 的镜像</span></span><br><span class="line">docker rmi image-id</span><br><span class="line"><span class="comment"># 查看 volume 列表</span></span><br><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> <span class="built_in">ls</span></span></span><br><span class="line"><span class="comment"># 查看网络列表</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure>



<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><ol>
<li>使用docker运行后，改变项目代码不会立刻生效，需要重新build和run</li>
<li>容器中生成的数据，如日志文件等，容器删除后就会丢失</li>
</ol>
<h3 id="几种挂载方式"><a href="#几种挂载方式" class="headerlink" title="几种挂载方式"></a>几种挂载方式</h3><ol>
<li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂在多个容器上</li>
<li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，更高效，Linux文件系统，适合存储数据库数据。可挂在多个容器上</li>
<li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享</li>
</ol>
<blockquote>
<p>文档参考：https:docs.docker.com&#x2F;storage&#x2F;</p>
</blockquote>
<p><img src="C:\Users\44104\AppData\Roaming\Typora\typora-user-images\image-20221012163606470.png" alt="image-20221012163606470" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h3><ol>
<li><code>bind mount</code> 方式用绝对路径 <code>-v D:/code:/app</code></li>
<li><code>volume</code> 方式，只需要一个名字 <code>-v db-data:/app</code></li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -p 8080:8080 --name test-hello -v D:/code:/app -d <span class="built_in">test</span>:v1</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h2 id="多容器通信"><a href="#多容器通信" class="headerlink" title="多容器通信"></a>多容器通信</h2><blockquote>
<p>项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。<br>这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。</p>
</blockquote>
<h3 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h3><p>实现多容器互通，放在同一网络中</p>
<blockquote>
<p>https:&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;network&#x2F;</p>
</blockquote>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><ol>
<li><p><strong>创建一个名为 <code>test-net</code> 网络：</strong></p>
<p><code>docker network create test-net </code></p>
</li>
<li><p><strong>运行Redis在 <code>test-net</code> 网络中，别名redis</strong></p>
<p><code>docker run -d --name redis --network test-net --network-alias redis redis:latest</code></p>
<p>–network-alias redis：代表当前容器加入到test-net局域网中</p>
</li>
<li><p><strong>修改代码中redis的地址为网络别名</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const redis = require(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line">let rds = redis.createClient(&#123;url: <span class="string">&quot;redis://redis:6379&quot;</span>&#125;);</span><br><span class="line">rds.on(<span class="string">&#x27;connect&#x27;</span>, ()=&gt; console.log(<span class="string">&#x27;redis connect ok&#x27;</span>))</span><br><span class="line">rds.connect();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行redis项目，使用同个网络</strong></p>
<p><code>docker run -p 8080:8080 -v D:/test:/app --network test-net -d test:v1</code></p>
</li>
<li><p><strong>查看数据</strong></p>
<p><code>http://localhost:8080/rdedis</code></p>
<p>容器终端查看数据否一致</p>
</li>
</ol>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><blockquote>
<p>一个项目，可能需要管理的容器太多，都要单独配置运行，指定网络。<br>使用 docker-compose 把项目的多个服务集合到一起，一键运行。</p>
</blockquote>
<h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h3><ol>
<li>如果是桌面版Docker，不需要额外安装，已包含</li>
<li>如果没有图形化界面，需要单独<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/#install-compose-on-linux-systems">安装</a>（运行 <code>docker-compose</code> 检查是否安装成功）</li>
</ol>
<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><blockquote>
<p>需要一个 <code>docker-compose.yaml</code>  文件</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:5.0.13</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis:/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br></pre></td></tr></table></figure>

<p>在 <code>docker-compose.yaml</code> 文件所在目录，执行：<code>docker-compose up</code> 就可以跑起来</p>
<h3 id="其余命令"><a href="#其余命令" class="headerlink" title="其余命令"></a>其余命令</h3><ol>
<li>在后台运行需要一个 -d 参数：<code>docker-compose -d</code></li>
<li>查看运行状态：<code>docker-compose ps</code></li>
<li>停止运行：<code>docker-compose stop</code></li>
<li>重启：<code>docker-compose restart</code></li>
<li>重启单个服务：<code>docker-compose restart service-name</code></li>
<li>进入容器命令行：<code>docker-compose exec service-name sh</code></li>
<li>查看容器运行log：<code>docker-compose logs [service-name]</code></li>
</ol>
<h2 id="发布和部署"><a href="#发布和部署" class="headerlink" title="发布和部署"></a>发布和部署</h2><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">镜像库</a></p>
<ol>
<li>创建一个镜像库</li>
<li>命令行登陆账号：<code>docker login -u username</code></li>
<li>新建一个tag，名字必须和注册账号保持一致：<code>docker tag test:v1 username/test:v1</code></li>
<li>推上去：<code>docker push username/test:v1</code></li>
<li>部署：<code>docker run -dp 8080:8080 username/test:v1</code></li>
</ol>
<h2 id="备份和迁移数据"><a href="#备份和迁移数据" class="headerlink" title="备份和迁移数据"></a>备份和迁移数据</h2><blockquote>
<p>没有挂载目录，删除容器后就会丢失数据</p>
<p><code>bind mount</code> 迁移数据直接复制目录就行</p>
<p><code>volume</code> 数据由容器创建和管理，需要特殊的方式将容器弄出来</p>
</blockquote>
<h3 id="备份和导入Volume流程"><a href="#备份和导入Volume流程" class="headerlink" title="备份和导入Volume流程"></a>备份和导入Volume流程</h3><ol>
<li>备份：<ul>
<li>运行一个 ubuntu 的容器，挂载需要备份的 volume 到容器，并且挂载宿主机目录到容器里的备份目录</li>
<li>运行 tar 命令把数据压缩为一个文件</li>
<li>把备份文件复制到需要导入的机器</li>
</ul>
</li>
<li>导入：<ul>
<li>运行 ubuntu 容器，挂载容器的 volume，并且挂载宿主机备份文件所在目录到容器里</li>
<li>运行 tar 命令解压备份文件到指定目录</li>
</ul>
</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote>
<p>备份MongoDB数据演示</p>
</blockquote>
<ol>
<li>运行一个 mongodb，创建一个名叫<code>mongo-data</code>的 volume 指向容器的 &#x2F;data 目录<br><code>docker run -p 27018:27017 --name mongo -v mongo-data:/data -d mongo:4.4</code></li>
<li>运行一个 Ubuntu 的容器，挂载<code>mongo</code>容器的所有 volume，映射宿主机的 backup 目录到容器里面的 &#x2F;backup 目录，然后运行 tar 命令把数据压缩打包<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu tar cvf /backup/backup.tar /data/</code><ul>
<li><code>--rm</code>：存在同名容器就删除</li>
<li><code>--volumes-from</code>：从选定容器中挂载volume</li>
<li><code>Ubuntu</code>：镜像使用系统</li>
<li><code>tar</code>：压缩</li>
</ul>
</li>
</ol>
<p>最后你就可以拿着这个 backup.tar 文件去其他地方导入了。</p>
<blockquote>
<p>恢复 Volume 数据演示</p>
</blockquote>
<ul>
<li>运行一个 ubuntu 容器，挂载 mongo 容器的所有 volumes，然后读取 &#x2F;backup 目录中的备份文件，解压到 &#x2F;data&#x2F; 目录<br><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu bash -c &quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</code></li>
</ul>

</article>
    
    

</div>
<div class="trm-post-next-prev row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            Other Articles
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2024/02/20/03-%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/git%20&%20workflow/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" #.">
                    Unclassified
                </a>
            </div>
            <h5>
                <a href="/2024/02/20/03-%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/git%20&%20workflow/" class="trm-anima-link">
                    
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>24/02/20</li>
                <li>16:24</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2024/02/20/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/04.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8/TensorRT/TensorRT-Yolov5/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" #.">
                    Unclassified
                </a>
            </div>
            <h5>
                <a href="/2024/02/20/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/04.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8/TensorRT/TensorRT-Yolov5/" class="trm-anima-link">
                    
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>24/02/20</li>
                <li>16:24</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-scroll-animation">

    

    
        <div class="trm-footer-item">
            <span>© 2020- 2024</span>
            <span class="footer-separator"data-separator=" · "></span>
            <span class="trm-accent-color">星唯向导</span>
        </div>
    


    <!--添加运行时间-->
    <span id="sitetime"></span>
    <script language=javascript>
	    function siteTime(){
		    window.setTimeout("siteTime()", 1000);
		    var seconds = 1000;
		    var minutes = seconds * 60;
		    var hours = minutes * 60;
		    var days = hours * 24;
		    var years = days * 365;
		    var today = new Date();
		    var todayYear = today.getFullYear();
		    var todayMonth = today.getMonth()+1;
		    var todayDate = today.getDate();
		    var todayHour = today.getHours();
		    var todayMinute = today.getMinutes();
		    var todaySecond = today.getSeconds();
		/* 
        Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		    var t1 = Date.UTC(2023,05,25,18,12,20); //北京时间2018-2-13 00:00:00
		    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		    var diff = t2-t1;
		    var diffYears = Math.floor(diff/years);
		    var diffDays = Math.floor((diff/days)-diffYears*365);
		    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		    document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	    }
	    siteTime();
    </script>
    <!--// 添加运行时间-->

      

     

    
        <div class="trm-footer-item">
            在年轻的飞奔里，拥抱迎面而来的风~
        </div>
     
</footer>
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="trm-post-toc">
      <div class="trm-post-toc-header">
        Article table of contents
				<span id="post-toc-top">
					TOP
				</span>
      </div>
      <div class="trm-post-toc-content">
        <ol class="trm-toc"><li class="trm-toc-item trm-toc-level-1" title="Docker"><a rel="nofollow" class="trm-toc-link" href="#Docker"><span class="trm-toc-number">1.</span> <span class="trm-toc-text">Docker</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="简介与安装"><a rel="nofollow" class="trm-toc-link" href="#简介与安装"><span class="trm-toc-number">1.1.</span> <span class="trm-toc-text">简介与安装</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="What？"><a rel="nofollow" class="trm-toc-link" href="#What？"><span class="trm-toc-number">1.1.1.</span> <span class="trm-toc-text">What？</span></a></li><li class="trm-toc-item trm-toc-level-3" title="虚拟机对比"><a rel="nofollow" class="trm-toc-link" href="#虚拟机对比"><span class="trm-toc-number">1.1.2.</span> <span class="trm-toc-text">虚拟机对比</span></a></li><li class="trm-toc-item trm-toc-level-3" title="打包+分发+部署"><a rel="nofollow" class="trm-toc-link" href="#打包-分发-部署"><span class="trm-toc-number">1.1.3.</span> <span class="trm-toc-text">打包+分发+部署</span></a></li><li class="trm-toc-item trm-toc-level-3" title="部署优势"><a rel="nofollow" class="trm-toc-link" href="#部署优势"><span class="trm-toc-number">1.1.4.</span> <span class="trm-toc-text">部署优势</span></a></li><li class="trm-toc-item trm-toc-level-3" title="用来做什么"><a rel="nofollow" class="trm-toc-link" href="#用来做什么"><span class="trm-toc-number">1.1.5.</span> <span class="trm-toc-text">用来做什么</span></a></li><li class="trm-toc-item trm-toc-level-3" title="镜像+容器(重)"><a rel="nofollow" class="trm-toc-link" href="#镜像-容器-重"><span class="trm-toc-number">1.1.6.</span> <span class="trm-toc-text">镜像+容器(重)</span></a></li><li class="trm-toc-item trm-toc-level-3" title="安装"><a rel="nofollow" class="trm-toc-link" href="#安装"><span class="trm-toc-number">1.1.7.</span> <span class="trm-toc-text">安装</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="快速安装软件"><a rel="nofollow" class="trm-toc-link" href="#快速安装软件"><span class="trm-toc-number">1.2.</span> <span class="trm-toc-text">快速安装软件</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="直接安装的缺点："><a rel="nofollow" class="trm-toc-link" href="#直接安装的缺点："><span class="trm-toc-number">1.2.1.</span> <span class="trm-toc-text">直接安装的缺点：</span></a></li><li class="trm-toc-item trm-toc-level-3" title="Docker安装的优点："><a rel="nofollow" class="trm-toc-link" href="#Docker安装的优点："><span class="trm-toc-number">1.2.2.</span> <span class="trm-toc-text">Docker安装的优点：</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="制作镜像"><a rel="nofollow" class="trm-toc-link" href="#制作镜像"><span class="trm-toc-number">1.3.</span> <span class="trm-toc-text">制作镜像</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="编写Dockerfile"><a rel="nofollow" class="trm-toc-link" href="#编写Dockerfile"><span class="trm-toc-number">1.3.1.</span> <span class="trm-toc-text">编写Dockerfile</span></a></li><li class="trm-toc-item trm-toc-level-3" title="Build为镜像（安装包）和运行"><a rel="nofollow" class="trm-toc-link" href="#Build为镜像（安装包）和运行"><span class="trm-toc-number">1.3.2.</span> <span class="trm-toc-text">Build为镜像（安装包）和运行</span></a></li><li class="trm-toc-item trm-toc-level-3" title="更多相关命令"><a rel="nofollow" class="trm-toc-link" href="#更多相关命令"><span class="trm-toc-number">1.3.3.</span> <span class="trm-toc-text">更多相关命令</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="目录挂载"><a rel="nofollow" class="trm-toc-link" href="#目录挂载"><span class="trm-toc-number">1.4.</span> <span class="trm-toc-text">目录挂载</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="现存问题"><a rel="nofollow" class="trm-toc-link" href="#现存问题"><span class="trm-toc-number">1.4.1.</span> <span class="trm-toc-text">现存问题</span></a></li><li class="trm-toc-item trm-toc-level-3" title="几种挂载方式"><a rel="nofollow" class="trm-toc-link" href="#几种挂载方式"><span class="trm-toc-number">1.4.2.</span> <span class="trm-toc-text">几种挂载方式</span></a></li><li class="trm-toc-item trm-toc-level-3" title="挂载演示"><a rel="nofollow" class="trm-toc-link" href="#挂载演示"><span class="trm-toc-number">1.4.3.</span> <span class="trm-toc-text">挂载演示</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="多容器通信"><a rel="nofollow" class="trm-toc-link" href="#多容器通信"><span class="trm-toc-number">1.5.</span> <span class="trm-toc-text">多容器通信</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="创建虚拟网络"><a rel="nofollow" class="trm-toc-link" href="#创建虚拟网络"><span class="trm-toc-number">1.5.1.</span> <span class="trm-toc-text">创建虚拟网络</span></a></li><li class="trm-toc-item trm-toc-level-3" title="演示"><a rel="nofollow" class="trm-toc-link" href="#演示"><span class="trm-toc-number">1.5.2.</span> <span class="trm-toc-text">演示</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="Docker-Compose"><a rel="nofollow" class="trm-toc-link" href="#Docker-Compose"><span class="trm-toc-number">1.6.</span> <span class="trm-toc-text">Docker-Compose</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="安装Docker Compose"><a rel="nofollow" class="trm-toc-link" href="#安装Docker-Compose"><span class="trm-toc-number">1.6.1.</span> <span class="trm-toc-text">安装Docker Compose</span></a></li><li class="trm-toc-item trm-toc-level-3" title="编写脚本"><a rel="nofollow" class="trm-toc-link" href="#编写脚本"><span class="trm-toc-number">1.6.2.</span> <span class="trm-toc-text">编写脚本</span></a></li><li class="trm-toc-item trm-toc-level-3" title="其余命令"><a rel="nofollow" class="trm-toc-link" href="#其余命令"><span class="trm-toc-number">1.6.3.</span> <span class="trm-toc-text">其余命令</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="发布和部署"><a rel="nofollow" class="trm-toc-link" href="#发布和部署"><span class="trm-toc-number">1.7.</span> <span class="trm-toc-text">发布和部署</span></a></li><li class="trm-toc-item trm-toc-level-2" title="备份和迁移数据"><a rel="nofollow" class="trm-toc-link" href="#备份和迁移数据"><span class="trm-toc-number">1.8.</span> <span class="trm-toc-text">备份和迁移数据</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="备份和导入Volume流程"><a rel="nofollow" class="trm-toc-link" href="#备份和导入Volume流程"><span class="trm-toc-number">1.8.1.</span> <span class="trm-toc-text">备份和导入Volume流程</span></a></li></ol></li></ol></li></ol>
      </div>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="Open toc">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="Read Mode" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="Back To Top">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    



<!-- CDN -->


    

    

    




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.1.10"></script>

</body>

</html>